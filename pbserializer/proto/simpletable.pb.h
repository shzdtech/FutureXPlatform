// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: simpletable.proto

#ifndef PROTOBUF_simpletable_2eproto__INCLUDED
#define PROTOBUF_simpletable_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "commondefine.pb.h"
// @@protoc_insertion_point(includes)

namespace Micro {
namespace Future {
namespace Message {
namespace Business {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_simpletable_2eproto();
void protobuf_AssignDesc_simpletable_2eproto();
void protobuf_ShutdownFile_simpletable_2eproto();

class ComplexTable;
class NamedDoubleVector;
class NamedIntVector;
class NamedStringVector;
class SimpleDoubleTable;
class SimpleIntTable;
class SimpleStringTable;

// ===================================================================

class NamedStringVector : public ::google::protobuf::Message {
 public:
  NamedStringVector();
  virtual ~NamedStringVector();

  NamedStringVector(const NamedStringVector& from);

  inline NamedStringVector& operator=(const NamedStringVector& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NamedStringVector& default_instance();

  void Swap(NamedStringVector* other);

  // implements Message ----------------------------------------------

  inline NamedStringVector* New() const { return New(NULL); }

  NamedStringVector* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NamedStringVector& from);
  void MergeFrom(const NamedStringVector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NamedStringVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated string entry = 2;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 2;
  const ::std::string& entry(int index) const;
  ::std::string* mutable_entry(int index);
  void set_entry(int index, const ::std::string& value);
  void set_entry(int index, const char* value);
  void set_entry(int index, const char* value, size_t size);
  ::std::string* add_entry();
  void add_entry(const ::std::string& value);
  void add_entry(const char* value);
  void add_entry(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& entry() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_entry();

  // @@protoc_insertion_point(class_scope:Micro.Future.Message.Business.NamedStringVector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> entry_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_simpletable_2eproto();
  friend void protobuf_AssignDesc_simpletable_2eproto();
  friend void protobuf_ShutdownFile_simpletable_2eproto();

  void InitAsDefaultInstance();
  static NamedStringVector* default_instance_;
};
// -------------------------------------------------------------------

class NamedIntVector : public ::google::protobuf::Message {
 public:
  NamedIntVector();
  virtual ~NamedIntVector();

  NamedIntVector(const NamedIntVector& from);

  inline NamedIntVector& operator=(const NamedIntVector& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NamedIntVector& default_instance();

  void Swap(NamedIntVector* other);

  // implements Message ----------------------------------------------

  inline NamedIntVector* New() const { return New(NULL); }

  NamedIntVector* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NamedIntVector& from);
  void MergeFrom(const NamedIntVector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NamedIntVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated int32 entry = 2;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 2;
  ::google::protobuf::int32 entry(int index) const;
  void set_entry(int index, ::google::protobuf::int32 value);
  void add_entry(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      entry() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_entry();

  // @@protoc_insertion_point(class_scope:Micro.Future.Message.Business.NamedIntVector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > entry_;
  mutable int _entry_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_simpletable_2eproto();
  friend void protobuf_AssignDesc_simpletable_2eproto();
  friend void protobuf_ShutdownFile_simpletable_2eproto();

  void InitAsDefaultInstance();
  static NamedIntVector* default_instance_;
};
// -------------------------------------------------------------------

class NamedDoubleVector : public ::google::protobuf::Message {
 public:
  NamedDoubleVector();
  virtual ~NamedDoubleVector();

  NamedDoubleVector(const NamedDoubleVector& from);

  inline NamedDoubleVector& operator=(const NamedDoubleVector& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NamedDoubleVector& default_instance();

  void Swap(NamedDoubleVector* other);

  // implements Message ----------------------------------------------

  inline NamedDoubleVector* New() const { return New(NULL); }

  NamedDoubleVector* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NamedDoubleVector& from);
  void MergeFrom(const NamedDoubleVector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NamedDoubleVector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated double entry = 2;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 2;
  double entry(int index) const;
  void set_entry(int index, double value);
  void add_entry(double value);
  const ::google::protobuf::RepeatedField< double >&
      entry() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_entry();

  // @@protoc_insertion_point(class_scope:Micro.Future.Message.Business.NamedDoubleVector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedField< double > entry_;
  mutable int _entry_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_simpletable_2eproto();
  friend void protobuf_AssignDesc_simpletable_2eproto();
  friend void protobuf_ShutdownFile_simpletable_2eproto();

  void InitAsDefaultInstance();
  static NamedDoubleVector* default_instance_;
};
// -------------------------------------------------------------------

class SimpleIntTable : public ::google::protobuf::Message {
 public:
  SimpleIntTable();
  virtual ~SimpleIntTable();

  SimpleIntTable(const SimpleIntTable& from);

  inline SimpleIntTable& operator=(const SimpleIntTable& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleIntTable& default_instance();

  void Swap(SimpleIntTable* other);

  // implements Message ----------------------------------------------

  inline SimpleIntTable* New() const { return New(NULL); }

  SimpleIntTable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleIntTable& from);
  void MergeFrom(const SimpleIntTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleIntTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Micro.Future.Message.Business.DataHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::Micro::Future::Message::Business::DataHeader& header() const;
  ::Micro::Future::Message::Business::DataHeader* mutable_header();
  ::Micro::Future::Message::Business::DataHeader* release_header();
  void set_allocated_header(::Micro::Future::Message::Business::DataHeader* header);

  // repeated .Micro.Future.Message.Business.NamedIntVector columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  const ::Micro::Future::Message::Business::NamedIntVector& columns(int index) const;
  ::Micro::Future::Message::Business::NamedIntVector* mutable_columns(int index);
  ::Micro::Future::Message::Business::NamedIntVector* add_columns();
  ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedIntVector >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedIntVector >&
      columns() const;

  // @@protoc_insertion_point(class_scope:Micro.Future.Message.Business.SimpleIntTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Micro::Future::Message::Business::DataHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedIntVector > columns_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_simpletable_2eproto();
  friend void protobuf_AssignDesc_simpletable_2eproto();
  friend void protobuf_ShutdownFile_simpletable_2eproto();

  void InitAsDefaultInstance();
  static SimpleIntTable* default_instance_;
};
// -------------------------------------------------------------------

class SimpleStringTable : public ::google::protobuf::Message {
 public:
  SimpleStringTable();
  virtual ~SimpleStringTable();

  SimpleStringTable(const SimpleStringTable& from);

  inline SimpleStringTable& operator=(const SimpleStringTable& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleStringTable& default_instance();

  void Swap(SimpleStringTable* other);

  // implements Message ----------------------------------------------

  inline SimpleStringTable* New() const { return New(NULL); }

  SimpleStringTable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleStringTable& from);
  void MergeFrom(const SimpleStringTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleStringTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Micro.Future.Message.Business.DataHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::Micro::Future::Message::Business::DataHeader& header() const;
  ::Micro::Future::Message::Business::DataHeader* mutable_header();
  ::Micro::Future::Message::Business::DataHeader* release_header();
  void set_allocated_header(::Micro::Future::Message::Business::DataHeader* header);

  // repeated .Micro.Future.Message.Business.NamedStringVector columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  const ::Micro::Future::Message::Business::NamedStringVector& columns(int index) const;
  ::Micro::Future::Message::Business::NamedStringVector* mutable_columns(int index);
  ::Micro::Future::Message::Business::NamedStringVector* add_columns();
  ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedStringVector >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedStringVector >&
      columns() const;

  // @@protoc_insertion_point(class_scope:Micro.Future.Message.Business.SimpleStringTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Micro::Future::Message::Business::DataHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedStringVector > columns_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_simpletable_2eproto();
  friend void protobuf_AssignDesc_simpletable_2eproto();
  friend void protobuf_ShutdownFile_simpletable_2eproto();

  void InitAsDefaultInstance();
  static SimpleStringTable* default_instance_;
};
// -------------------------------------------------------------------

class SimpleDoubleTable : public ::google::protobuf::Message {
 public:
  SimpleDoubleTable();
  virtual ~SimpleDoubleTable();

  SimpleDoubleTable(const SimpleDoubleTable& from);

  inline SimpleDoubleTable& operator=(const SimpleDoubleTable& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleDoubleTable& default_instance();

  void Swap(SimpleDoubleTable* other);

  // implements Message ----------------------------------------------

  inline SimpleDoubleTable* New() const { return New(NULL); }

  SimpleDoubleTable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleDoubleTable& from);
  void MergeFrom(const SimpleDoubleTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleDoubleTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Micro.Future.Message.Business.DataHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::Micro::Future::Message::Business::DataHeader& header() const;
  ::Micro::Future::Message::Business::DataHeader* mutable_header();
  ::Micro::Future::Message::Business::DataHeader* release_header();
  void set_allocated_header(::Micro::Future::Message::Business::DataHeader* header);

  // repeated .Micro.Future.Message.Business.NamedDoubleVector columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  const ::Micro::Future::Message::Business::NamedDoubleVector& columns(int index) const;
  ::Micro::Future::Message::Business::NamedDoubleVector* mutable_columns(int index);
  ::Micro::Future::Message::Business::NamedDoubleVector* add_columns();
  ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedDoubleVector >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedDoubleVector >&
      columns() const;

  // @@protoc_insertion_point(class_scope:Micro.Future.Message.Business.SimpleDoubleTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Micro::Future::Message::Business::DataHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedDoubleVector > columns_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_simpletable_2eproto();
  friend void protobuf_AssignDesc_simpletable_2eproto();
  friend void protobuf_ShutdownFile_simpletable_2eproto();

  void InitAsDefaultInstance();
  static SimpleDoubleTable* default_instance_;
};
// -------------------------------------------------------------------

class ComplexTable : public ::google::protobuf::Message {
 public:
  ComplexTable();
  virtual ~ComplexTable();

  ComplexTable(const ComplexTable& from);

  inline ComplexTable& operator=(const ComplexTable& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComplexTable& default_instance();

  void Swap(ComplexTable* other);

  // implements Message ----------------------------------------------

  inline ComplexTable* New() const { return New(NULL); }

  ComplexTable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComplexTable& from);
  void MergeFrom(const ComplexTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComplexTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Micro.Future.Message.Business.DataHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::Micro::Future::Message::Business::DataHeader& header() const;
  ::Micro::Future::Message::Business::DataHeader* mutable_header();
  ::Micro::Future::Message::Business::DataHeader* release_header();
  void set_allocated_header(::Micro::Future::Message::Business::DataHeader* header);

  // optional .Micro.Future.Message.Business.SimpleIntTable intTable = 2;
  bool has_inttable() const;
  void clear_inttable();
  static const int kIntTableFieldNumber = 2;
  const ::Micro::Future::Message::Business::SimpleIntTable& inttable() const;
  ::Micro::Future::Message::Business::SimpleIntTable* mutable_inttable();
  ::Micro::Future::Message::Business::SimpleIntTable* release_inttable();
  void set_allocated_inttable(::Micro::Future::Message::Business::SimpleIntTable* inttable);

  // optional .Micro.Future.Message.Business.SimpleDoubleTable doubleTable = 3;
  bool has_doubletable() const;
  void clear_doubletable();
  static const int kDoubleTableFieldNumber = 3;
  const ::Micro::Future::Message::Business::SimpleDoubleTable& doubletable() const;
  ::Micro::Future::Message::Business::SimpleDoubleTable* mutable_doubletable();
  ::Micro::Future::Message::Business::SimpleDoubleTable* release_doubletable();
  void set_allocated_doubletable(::Micro::Future::Message::Business::SimpleDoubleTable* doubletable);

  // optional .Micro.Future.Message.Business.SimpleStringTable stringTable = 4;
  bool has_stringtable() const;
  void clear_stringtable();
  static const int kStringTableFieldNumber = 4;
  const ::Micro::Future::Message::Business::SimpleStringTable& stringtable() const;
  ::Micro::Future::Message::Business::SimpleStringTable* mutable_stringtable();
  ::Micro::Future::Message::Business::SimpleStringTable* release_stringtable();
  void set_allocated_stringtable(::Micro::Future::Message::Business::SimpleStringTable* stringtable);

  // optional .Micro.Future.Message.Business.ComplexTable nestedTable = 5;
  bool has_nestedtable() const;
  void clear_nestedtable();
  static const int kNestedTableFieldNumber = 5;
  const ::Micro::Future::Message::Business::ComplexTable& nestedtable() const;
  ::Micro::Future::Message::Business::ComplexTable* mutable_nestedtable();
  ::Micro::Future::Message::Business::ComplexTable* release_nestedtable();
  void set_allocated_nestedtable(::Micro::Future::Message::Business::ComplexTable* nestedtable);

  // @@protoc_insertion_point(class_scope:Micro.Future.Message.Business.ComplexTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Micro::Future::Message::Business::DataHeader* header_;
  ::Micro::Future::Message::Business::SimpleIntTable* inttable_;
  ::Micro::Future::Message::Business::SimpleDoubleTable* doubletable_;
  ::Micro::Future::Message::Business::SimpleStringTable* stringtable_;
  ::Micro::Future::Message::Business::ComplexTable* nestedtable_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_simpletable_2eproto();
  friend void protobuf_AssignDesc_simpletable_2eproto();
  friend void protobuf_ShutdownFile_simpletable_2eproto();

  void InitAsDefaultInstance();
  static ComplexTable* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// NamedStringVector

// optional string name = 1;
inline void NamedStringVector::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NamedStringVector::name() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.NamedStringVector.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NamedStringVector::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Micro.Future.Message.Business.NamedStringVector.name)
}
inline void NamedStringVector::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Micro.Future.Message.Business.NamedStringVector.name)
}
inline void NamedStringVector::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Micro.Future.Message.Business.NamedStringVector.name)
}
inline ::std::string* NamedStringVector::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.NamedStringVector.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NamedStringVector::release_name() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.NamedStringVector.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NamedStringVector::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.NamedStringVector.name)
}

// repeated string entry = 2;
inline int NamedStringVector::entry_size() const {
  return entry_.size();
}
inline void NamedStringVector::clear_entry() {
  entry_.Clear();
}
inline const ::std::string& NamedStringVector::entry(int index) const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.NamedStringVector.entry)
  return entry_.Get(index);
}
inline ::std::string* NamedStringVector::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.NamedStringVector.entry)
  return entry_.Mutable(index);
}
inline void NamedStringVector::set_entry(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Micro.Future.Message.Business.NamedStringVector.entry)
  entry_.Mutable(index)->assign(value);
}
inline void NamedStringVector::set_entry(int index, const char* value) {
  entry_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Micro.Future.Message.Business.NamedStringVector.entry)
}
inline void NamedStringVector::set_entry(int index, const char* value, size_t size) {
  entry_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Micro.Future.Message.Business.NamedStringVector.entry)
}
inline ::std::string* NamedStringVector::add_entry() {
  // @@protoc_insertion_point(field_add_mutable:Micro.Future.Message.Business.NamedStringVector.entry)
  return entry_.Add();
}
inline void NamedStringVector::add_entry(const ::std::string& value) {
  entry_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Micro.Future.Message.Business.NamedStringVector.entry)
}
inline void NamedStringVector::add_entry(const char* value) {
  entry_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Micro.Future.Message.Business.NamedStringVector.entry)
}
inline void NamedStringVector::add_entry(const char* value, size_t size) {
  entry_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Micro.Future.Message.Business.NamedStringVector.entry)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NamedStringVector::entry() const {
  // @@protoc_insertion_point(field_list:Micro.Future.Message.Business.NamedStringVector.entry)
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NamedStringVector::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:Micro.Future.Message.Business.NamedStringVector.entry)
  return &entry_;
}

// -------------------------------------------------------------------

// NamedIntVector

// optional string name = 1;
inline void NamedIntVector::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NamedIntVector::name() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.NamedIntVector.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NamedIntVector::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Micro.Future.Message.Business.NamedIntVector.name)
}
inline void NamedIntVector::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Micro.Future.Message.Business.NamedIntVector.name)
}
inline void NamedIntVector::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Micro.Future.Message.Business.NamedIntVector.name)
}
inline ::std::string* NamedIntVector::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.NamedIntVector.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NamedIntVector::release_name() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.NamedIntVector.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NamedIntVector::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.NamedIntVector.name)
}

// repeated int32 entry = 2;
inline int NamedIntVector::entry_size() const {
  return entry_.size();
}
inline void NamedIntVector::clear_entry() {
  entry_.Clear();
}
inline ::google::protobuf::int32 NamedIntVector::entry(int index) const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.NamedIntVector.entry)
  return entry_.Get(index);
}
inline void NamedIntVector::set_entry(int index, ::google::protobuf::int32 value) {
  entry_.Set(index, value);
  // @@protoc_insertion_point(field_set:Micro.Future.Message.Business.NamedIntVector.entry)
}
inline void NamedIntVector::add_entry(::google::protobuf::int32 value) {
  entry_.Add(value);
  // @@protoc_insertion_point(field_add:Micro.Future.Message.Business.NamedIntVector.entry)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NamedIntVector::entry() const {
  // @@protoc_insertion_point(field_list:Micro.Future.Message.Business.NamedIntVector.entry)
  return entry_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NamedIntVector::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:Micro.Future.Message.Business.NamedIntVector.entry)
  return &entry_;
}

// -------------------------------------------------------------------

// NamedDoubleVector

// optional string name = 1;
inline void NamedDoubleVector::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NamedDoubleVector::name() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.NamedDoubleVector.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NamedDoubleVector::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Micro.Future.Message.Business.NamedDoubleVector.name)
}
inline void NamedDoubleVector::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Micro.Future.Message.Business.NamedDoubleVector.name)
}
inline void NamedDoubleVector::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Micro.Future.Message.Business.NamedDoubleVector.name)
}
inline ::std::string* NamedDoubleVector::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.NamedDoubleVector.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NamedDoubleVector::release_name() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.NamedDoubleVector.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NamedDoubleVector::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.NamedDoubleVector.name)
}

// repeated double entry = 2;
inline int NamedDoubleVector::entry_size() const {
  return entry_.size();
}
inline void NamedDoubleVector::clear_entry() {
  entry_.Clear();
}
inline double NamedDoubleVector::entry(int index) const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.NamedDoubleVector.entry)
  return entry_.Get(index);
}
inline void NamedDoubleVector::set_entry(int index, double value) {
  entry_.Set(index, value);
  // @@protoc_insertion_point(field_set:Micro.Future.Message.Business.NamedDoubleVector.entry)
}
inline void NamedDoubleVector::add_entry(double value) {
  entry_.Add(value);
  // @@protoc_insertion_point(field_add:Micro.Future.Message.Business.NamedDoubleVector.entry)
}
inline const ::google::protobuf::RepeatedField< double >&
NamedDoubleVector::entry() const {
  // @@protoc_insertion_point(field_list:Micro.Future.Message.Business.NamedDoubleVector.entry)
  return entry_;
}
inline ::google::protobuf::RepeatedField< double >*
NamedDoubleVector::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:Micro.Future.Message.Business.NamedDoubleVector.entry)
  return &entry_;
}

// -------------------------------------------------------------------

// SimpleIntTable

// optional .Micro.Future.Message.Business.DataHeader header = 1;
inline bool SimpleIntTable::has_header() const {
  return !_is_default_instance_ && header_ != NULL;
}
inline void SimpleIntTable::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::Micro::Future::Message::Business::DataHeader& SimpleIntTable::header() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.SimpleIntTable.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Micro::Future::Message::Business::DataHeader* SimpleIntTable::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::Micro::Future::Message::Business::DataHeader;
  }
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.SimpleIntTable.header)
  return header_;
}
inline ::Micro::Future::Message::Business::DataHeader* SimpleIntTable::release_header() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.SimpleIntTable.header)
  
  ::Micro::Future::Message::Business::DataHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SimpleIntTable::set_allocated_header(::Micro::Future::Message::Business::DataHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.SimpleIntTable.header)
}

// repeated .Micro.Future.Message.Business.NamedIntVector columns = 2;
inline int SimpleIntTable::columns_size() const {
  return columns_.size();
}
inline void SimpleIntTable::clear_columns() {
  columns_.Clear();
}
inline const ::Micro::Future::Message::Business::NamedIntVector& SimpleIntTable::columns(int index) const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.SimpleIntTable.columns)
  return columns_.Get(index);
}
inline ::Micro::Future::Message::Business::NamedIntVector* SimpleIntTable::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.SimpleIntTable.columns)
  return columns_.Mutable(index);
}
inline ::Micro::Future::Message::Business::NamedIntVector* SimpleIntTable::add_columns() {
  // @@protoc_insertion_point(field_add:Micro.Future.Message.Business.SimpleIntTable.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedIntVector >*
SimpleIntTable::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:Micro.Future.Message.Business.SimpleIntTable.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedIntVector >&
SimpleIntTable::columns() const {
  // @@protoc_insertion_point(field_list:Micro.Future.Message.Business.SimpleIntTable.columns)
  return columns_;
}

// -------------------------------------------------------------------

// SimpleStringTable

// optional .Micro.Future.Message.Business.DataHeader header = 1;
inline bool SimpleStringTable::has_header() const {
  return !_is_default_instance_ && header_ != NULL;
}
inline void SimpleStringTable::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::Micro::Future::Message::Business::DataHeader& SimpleStringTable::header() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.SimpleStringTable.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Micro::Future::Message::Business::DataHeader* SimpleStringTable::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::Micro::Future::Message::Business::DataHeader;
  }
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.SimpleStringTable.header)
  return header_;
}
inline ::Micro::Future::Message::Business::DataHeader* SimpleStringTable::release_header() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.SimpleStringTable.header)
  
  ::Micro::Future::Message::Business::DataHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SimpleStringTable::set_allocated_header(::Micro::Future::Message::Business::DataHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.SimpleStringTable.header)
}

// repeated .Micro.Future.Message.Business.NamedStringVector columns = 2;
inline int SimpleStringTable::columns_size() const {
  return columns_.size();
}
inline void SimpleStringTable::clear_columns() {
  columns_.Clear();
}
inline const ::Micro::Future::Message::Business::NamedStringVector& SimpleStringTable::columns(int index) const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.SimpleStringTable.columns)
  return columns_.Get(index);
}
inline ::Micro::Future::Message::Business::NamedStringVector* SimpleStringTable::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.SimpleStringTable.columns)
  return columns_.Mutable(index);
}
inline ::Micro::Future::Message::Business::NamedStringVector* SimpleStringTable::add_columns() {
  // @@protoc_insertion_point(field_add:Micro.Future.Message.Business.SimpleStringTable.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedStringVector >*
SimpleStringTable::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:Micro.Future.Message.Business.SimpleStringTable.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedStringVector >&
SimpleStringTable::columns() const {
  // @@protoc_insertion_point(field_list:Micro.Future.Message.Business.SimpleStringTable.columns)
  return columns_;
}

// -------------------------------------------------------------------

// SimpleDoubleTable

// optional .Micro.Future.Message.Business.DataHeader header = 1;
inline bool SimpleDoubleTable::has_header() const {
  return !_is_default_instance_ && header_ != NULL;
}
inline void SimpleDoubleTable::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::Micro::Future::Message::Business::DataHeader& SimpleDoubleTable::header() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.SimpleDoubleTable.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Micro::Future::Message::Business::DataHeader* SimpleDoubleTable::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::Micro::Future::Message::Business::DataHeader;
  }
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.SimpleDoubleTable.header)
  return header_;
}
inline ::Micro::Future::Message::Business::DataHeader* SimpleDoubleTable::release_header() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.SimpleDoubleTable.header)
  
  ::Micro::Future::Message::Business::DataHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SimpleDoubleTable::set_allocated_header(::Micro::Future::Message::Business::DataHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.SimpleDoubleTable.header)
}

// repeated .Micro.Future.Message.Business.NamedDoubleVector columns = 2;
inline int SimpleDoubleTable::columns_size() const {
  return columns_.size();
}
inline void SimpleDoubleTable::clear_columns() {
  columns_.Clear();
}
inline const ::Micro::Future::Message::Business::NamedDoubleVector& SimpleDoubleTable::columns(int index) const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.SimpleDoubleTable.columns)
  return columns_.Get(index);
}
inline ::Micro::Future::Message::Business::NamedDoubleVector* SimpleDoubleTable::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.SimpleDoubleTable.columns)
  return columns_.Mutable(index);
}
inline ::Micro::Future::Message::Business::NamedDoubleVector* SimpleDoubleTable::add_columns() {
  // @@protoc_insertion_point(field_add:Micro.Future.Message.Business.SimpleDoubleTable.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedDoubleVector >*
SimpleDoubleTable::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:Micro.Future.Message.Business.SimpleDoubleTable.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Micro::Future::Message::Business::NamedDoubleVector >&
SimpleDoubleTable::columns() const {
  // @@protoc_insertion_point(field_list:Micro.Future.Message.Business.SimpleDoubleTable.columns)
  return columns_;
}

// -------------------------------------------------------------------

// ComplexTable

// optional .Micro.Future.Message.Business.DataHeader header = 1;
inline bool ComplexTable::has_header() const {
  return !_is_default_instance_ && header_ != NULL;
}
inline void ComplexTable::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::Micro::Future::Message::Business::DataHeader& ComplexTable::header() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.ComplexTable.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Micro::Future::Message::Business::DataHeader* ComplexTable::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::Micro::Future::Message::Business::DataHeader;
  }
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.ComplexTable.header)
  return header_;
}
inline ::Micro::Future::Message::Business::DataHeader* ComplexTable::release_header() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.ComplexTable.header)
  
  ::Micro::Future::Message::Business::DataHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ComplexTable::set_allocated_header(::Micro::Future::Message::Business::DataHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.ComplexTable.header)
}

// optional .Micro.Future.Message.Business.SimpleIntTable intTable = 2;
inline bool ComplexTable::has_inttable() const {
  return !_is_default_instance_ && inttable_ != NULL;
}
inline void ComplexTable::clear_inttable() {
  if (GetArenaNoVirtual() == NULL && inttable_ != NULL) delete inttable_;
  inttable_ = NULL;
}
inline const ::Micro::Future::Message::Business::SimpleIntTable& ComplexTable::inttable() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.ComplexTable.intTable)
  return inttable_ != NULL ? *inttable_ : *default_instance_->inttable_;
}
inline ::Micro::Future::Message::Business::SimpleIntTable* ComplexTable::mutable_inttable() {
  
  if (inttable_ == NULL) {
    inttable_ = new ::Micro::Future::Message::Business::SimpleIntTable;
  }
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.ComplexTable.intTable)
  return inttable_;
}
inline ::Micro::Future::Message::Business::SimpleIntTable* ComplexTable::release_inttable() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.ComplexTable.intTable)
  
  ::Micro::Future::Message::Business::SimpleIntTable* temp = inttable_;
  inttable_ = NULL;
  return temp;
}
inline void ComplexTable::set_allocated_inttable(::Micro::Future::Message::Business::SimpleIntTable* inttable) {
  delete inttable_;
  inttable_ = inttable;
  if (inttable) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.ComplexTable.intTable)
}

// optional .Micro.Future.Message.Business.SimpleDoubleTable doubleTable = 3;
inline bool ComplexTable::has_doubletable() const {
  return !_is_default_instance_ && doubletable_ != NULL;
}
inline void ComplexTable::clear_doubletable() {
  if (GetArenaNoVirtual() == NULL && doubletable_ != NULL) delete doubletable_;
  doubletable_ = NULL;
}
inline const ::Micro::Future::Message::Business::SimpleDoubleTable& ComplexTable::doubletable() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.ComplexTable.doubleTable)
  return doubletable_ != NULL ? *doubletable_ : *default_instance_->doubletable_;
}
inline ::Micro::Future::Message::Business::SimpleDoubleTable* ComplexTable::mutable_doubletable() {
  
  if (doubletable_ == NULL) {
    doubletable_ = new ::Micro::Future::Message::Business::SimpleDoubleTable;
  }
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.ComplexTable.doubleTable)
  return doubletable_;
}
inline ::Micro::Future::Message::Business::SimpleDoubleTable* ComplexTable::release_doubletable() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.ComplexTable.doubleTable)
  
  ::Micro::Future::Message::Business::SimpleDoubleTable* temp = doubletable_;
  doubletable_ = NULL;
  return temp;
}
inline void ComplexTable::set_allocated_doubletable(::Micro::Future::Message::Business::SimpleDoubleTable* doubletable) {
  delete doubletable_;
  doubletable_ = doubletable;
  if (doubletable) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.ComplexTable.doubleTable)
}

// optional .Micro.Future.Message.Business.SimpleStringTable stringTable = 4;
inline bool ComplexTable::has_stringtable() const {
  return !_is_default_instance_ && stringtable_ != NULL;
}
inline void ComplexTable::clear_stringtable() {
  if (GetArenaNoVirtual() == NULL && stringtable_ != NULL) delete stringtable_;
  stringtable_ = NULL;
}
inline const ::Micro::Future::Message::Business::SimpleStringTable& ComplexTable::stringtable() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.ComplexTable.stringTable)
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::Micro::Future::Message::Business::SimpleStringTable* ComplexTable::mutable_stringtable() {
  
  if (stringtable_ == NULL) {
    stringtable_ = new ::Micro::Future::Message::Business::SimpleStringTable;
  }
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.ComplexTable.stringTable)
  return stringtable_;
}
inline ::Micro::Future::Message::Business::SimpleStringTable* ComplexTable::release_stringtable() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.ComplexTable.stringTable)
  
  ::Micro::Future::Message::Business::SimpleStringTable* temp = stringtable_;
  stringtable_ = NULL;
  return temp;
}
inline void ComplexTable::set_allocated_stringtable(::Micro::Future::Message::Business::SimpleStringTable* stringtable) {
  delete stringtable_;
  stringtable_ = stringtable;
  if (stringtable) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.ComplexTable.stringTable)
}

// optional .Micro.Future.Message.Business.ComplexTable nestedTable = 5;
inline bool ComplexTable::has_nestedtable() const {
  return !_is_default_instance_ && nestedtable_ != NULL;
}
inline void ComplexTable::clear_nestedtable() {
  if (GetArenaNoVirtual() == NULL && nestedtable_ != NULL) delete nestedtable_;
  nestedtable_ = NULL;
}
inline const ::Micro::Future::Message::Business::ComplexTable& ComplexTable::nestedtable() const {
  // @@protoc_insertion_point(field_get:Micro.Future.Message.Business.ComplexTable.nestedTable)
  return nestedtable_ != NULL ? *nestedtable_ : *default_instance_->nestedtable_;
}
inline ::Micro::Future::Message::Business::ComplexTable* ComplexTable::mutable_nestedtable() {
  
  if (nestedtable_ == NULL) {
    nestedtable_ = new ::Micro::Future::Message::Business::ComplexTable;
  }
  // @@protoc_insertion_point(field_mutable:Micro.Future.Message.Business.ComplexTable.nestedTable)
  return nestedtable_;
}
inline ::Micro::Future::Message::Business::ComplexTable* ComplexTable::release_nestedtable() {
  // @@protoc_insertion_point(field_release:Micro.Future.Message.Business.ComplexTable.nestedTable)
  
  ::Micro::Future::Message::Business::ComplexTable* temp = nestedtable_;
  nestedtable_ = NULL;
  return temp;
}
inline void ComplexTable::set_allocated_nestedtable(::Micro::Future::Message::Business::ComplexTable* nestedtable) {
  delete nestedtable_;
  nestedtable_ = nestedtable;
  if (nestedtable) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Micro.Future.Message.Business.ComplexTable.nestedTable)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Business
}  // namespace Message
}  // namespace Future
}  // namespace Micro

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_simpletable_2eproto__INCLUDED
